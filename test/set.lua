require("lunit")
local Set = require("collection/set")

describe("Set", function()
    describe("constructor", function()
        it("creates an empty set if no iterable is provided", function()
            local s = Set:new()
            expect(s).to.have.a.property("size", 0)
            expect(s:toSeq()).to.deep.equal({})
        end)
        it("optionally accepts a sequence of initial contents", function()
            local s = Set:new {10, 10, 20}
            expect(s).to.have.a.property("size", 2)
            expect(s:has(10)).to.equal(true)
            expect(s:has(20)).to.equal(true)
        end)
        it("optionally accepts an iterable of initial contents", function()
            local s1 = Set:new {10, 10, 20}
            local s2 = Set:new(s1:values())
            expect(s2).to.have.a.property("size", 2)
            expect(s2:has(10)).to.equal(true)
            expect(s2:has(20)).to.equal(true)
        end)
    end)
    describe(":add()", function()
        it("inserts an element", function()
            local s = Set:new()
            s:add("foo")
            s:add("bar")
            s:add("bar")
            expect(s).to.have.a.property("size", 2)
            expect(s:toSeq()).to.have.members({"foo", "bar"})
        end)
    end)
    describe(":clear()", function()
        it("deletes all elements", function()
            local s = Set:new()
            s:add("foo")
            s:add("bar")
            s:clear()
            expect(s).to.have.a.property("size", 0)
            expect(s:toSeq()).to.deep.equal({})
        end)
    end)
    describe(":delete()", function()
        it("deletes a specified element", function()
            local s = Set:new()
            s:add("foo")
            expect(s:delete("foo")).to.equal(true)
            expect(s:delete("bar")).to.equal(false)
            expect(s).to.have.a.property("size", 0)
            expect(s:toSeq()).to.deep.equal({})
        end)
    end)
    describe(":has()", function()
        it("checks if a given value is a member or not", function()
            local s = Set:new()
            s:add("foo")
            expect(s:has("foo")).to.equal(true)
            expect(s:has("bar")).to.equal(false)
        end)
    end)
    describe(":difference()", function()
        it("returns a difference", function()
            local s1 = Set:new()
            s1:add("foo")
            s1:add("bar")
            s1:add("baz")

            local s2 = Set:new()
            s2:add("foo")

            local s = s1:difference(s2)
            expect(s).to.have.a.property("size", 2)
            expect(s:toSeq()).to.have.members({"bar", "baz"})
        end)
    end)
    describe(":union()", function()
        it("returns a union", function()
            local s1 = Set:new {"foo", "bar"}
            local s2 = Set:new {"bar", "baz"}
            local s  = s1:union(s2)
            expect(s).to.have.a.property("size", 3)
            expect(s:toSeq()).to.have.members({"foo", "bar", "baz"})
        end)
    end)
    describe("..", function()
        it("is an alias to :union()", function()
            local s1 = Set:new {"foo", "bar"}
            local s2 = Set:new {"bar", "baz"}
            local s  = s1 .. s2
            expect(s).to.have.a.property("size", 3)
            expect(s:toSeq()).to.have.members({"foo", "bar", "baz"})
        end)
    end)
    describe(":values()", function()
        it("returns an iterator that iterates over elements in the set", function()
            local s   = Set:new {10, 20}
            local sum = 0
            for x in s:values() do
                sum = sum + x
            end
            expect(sum).to.equal(30)
        end)
    end)
    describe("tostring()", function()
        it("reasonably stringifies a set", function()
            local s = Set:new()
            s:add(1)
            expect(tostring(s)).to.equal("Set {1}")
        end)
    end)
end)
